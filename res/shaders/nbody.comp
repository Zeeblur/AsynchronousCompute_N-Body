#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

struct particle
{
	vec4 pos;								// Particle position
	vec4 vel;								// Particle velocity
};

// Binding 0 : Position storage buffer
layout(std140, binding = 0) buffer Pos 
{
   particle particles[ ];
};

layout (binding = 1) uniform UBO 
{
	float deltaT;
	float destX;
	float destY;
	int particleCount;
} ubo;

vec2 attraction(vec2 pos, vec2 attractPos) 
{
    vec2 delta = attractPos - pos;
	const float damp = 0.5;
    float dDampedDot = dot(delta, delta) + damp;
    float invDist = 1.0f / sqrt(dDampedDot);
    float invDistCubed = invDist*invDist*invDist;
    return delta * invDistCubed * 0.0035;
}

vec2 repulsion(vec2 pos, vec2 attractPos)
{
	vec2 delta = attractPos - pos;
	float targetDistance = sqrt(dot(delta, delta));
	return delta * (1.0 / (targetDistance * targetDistance * targetDistance)) * -0.000035;
}

layout (constant_id = 1) const float GRAVITY = 0.002;

void main() 
{

    // Current SSBO index
    uint index = gl_GlobalInvocationID.x;
	// Don't try to write beyond particle count
    if (index >= ubo.particleCount) 
		return;	

    // Read position and velocity
    vec4 vVel = particles[index].vel;
    vec4 vPos = particles[index].pos;

	// calculate acceleration
	vec4 acceleration = vec4(0.0);

	// for each particle calculate force
	for (int i = 0; i < ubo.particleCount; i++)
	{
		if (index == i)
			continue;

		vec4 dist = particles[i].pos - particles[index].pos;
		vec4 direction = normalize(dist);
		acceleration += direction * GRAVITY / dot(dist, dist);
	}

	vVel += (ubo.deltaT * acceleration);




    vPos += vVel * ubo.deltaT;


    // Write back	
	if ((vPos.x < -10.0) || (vPos.x > 10.0) || (vPos.y < -10.0) || (vPos.y > 10.0))
    	vVel = (-vVel * 0.3);
    else
    	particles[index].pos = vPos;

	if (index == 0)
		particles[index].pos = vec4(0.0);

	if (index == 2)
		particles[index].pos = vec4(2.0);

    particles[index].vel = vVel;

}

